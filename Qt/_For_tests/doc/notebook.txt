//--------------------------------------------------------
palette.setColor(QPalette::Window,          QColor(53,53,53));
palette.setColor(QPalette::WindowText,      Qt::white);
palette.setColor(QPalette::Base,            QColor(25,25,25));
palette.setColor(QPalette::AlternateBase,   QColor(53,53,53));
palette.setColor(QPalette::ToolTipBase,     Qt::white);
palette.setColor(QPalette::ToolTipText,     Qt::white);
palette.setColor(QPalette::Text,            Qt::white);
palette.setColor(QPalette::Button,          QColor(53,53,53));
palette.setColor(QPalette::ButtonText,      Qt::white);
palette.setColor(QPalette::BrightText,      Qt::red);
palette.setColor(QPalette::Link,            QColor(42, 130, 218));

palette.setColor(QPalette::Highlight,       QColor(42, 130, 218));
palette.setColor(QPalette::HighlightedText, Qt::black);
//--------------------------------------------------------
QWidgetList wl = qApp->allWidgets();
foreach (QWidget *w, wl)
{
    LogDock *log = dynamic_cast<LogDock *>(w);
    if(log)
    {
        connect(this, SIGNAL(info(QString)),    log, SLOT(infoLog(QString)));
        connect(this, SIGNAL(debug(QString)),   log, SLOT(debugLog(QString)));
        connect(this, SIGNAL(error(QString)),   log, SLOT(errorLog(QString)));
        connect(this, SIGNAL(trace(QString)),   log, SLOT(traceLog(QString)));

        connect(this,   SIGNAL(syslog(int,QString,QString)),
                log,    SLOT(syslog(int,QString,QString)));
        return;
    }
}
connect(this, SIGNAL(info(QString)),    this, SLOT(log(QString)));
connect(this, SIGNAL(debug(QString)),   this, SLOT(log(QString)));
connect(this, SIGNAL(error(QString)),   this, SLOT(log(QString)));
connect(this, SIGNAL(trace(QString)),   this, SLOT(log(QString)));

Q_UNUSED(parent);
//--------------------------------------------------------
class MyGrapherBox : public GrapherBox
{
    Q_OBJECT

public:
    MyGrapherBox(QWidget *parent = 0) :
        GrapherBox(parent)
    {
        set_visible_btn_all_ON(false);
        set_visible_btn_all_OFF(false);
        set_visible_btn_Clear(false);
        set_visible_btn_Load(false);
        set_visible_btn_Save(false);
        set_visible_btn_Statistic(false);
        set_visible_btn_Options(false);
    }

    ~MyGrapherBox()
    {

    }

};
//--------------------------------------------------------
QBitArray bytesToBits(const QByteArray &bytes) const
{
    QBitArray bits;
    bits.resize(bytes.size()*8);
    // Convert from QByteArray to QBitArray
    for(int i=0; i<bytes.count(); ++i)
        for(int b=0; b<8; ++b)
            bits.setBit(i*8+b, bytes.at(i)&(1<<(7-b)));
    return bits;
}
 
 
QByteArray bitsToBytes(const QBitArray &bits) const
{
    QByteArray bytes;
    bytes.resize(bits.size()/8);
 
    // Convert from QBitArray to QByteArray
    for(int b=0; b<bits.count(); ++b)
        bytes[b/8] = (bytes.at(b/8) | ((bits[b]?1:0)<<(b%8)));
    return bytes;
}
//--------------------------------------------------------
#if 0
<property name="palette">
 <palette>
  <active>

  <inactive>

   <colorrole role="WindowText">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>65</red>
      <green>113</green>
      <blue>145</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Button">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>32</red>
      <green>64</green>
      <blue>96</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Light">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>24</red>
      <green>48</green>
      <blue>44</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Text">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>65</red>
      <green>113</green>
      <blue>145</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="BrightText">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>24</red>
      <green>48</green>
      <blue>64</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="ButtonText">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>65</red>
      <green>113</green>
      <blue>145</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Base">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>24</red>
      <green>48</green>
      <blue>64</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Window">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>12</red>
      <green>24</green>
      <blue>32</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Shadow">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>65</red>
      <green>113</green>
      <blue>145</blue>
     </color>
    </brush>
   </colorrole>

  </inactive>

  <disabled>

   <colorrole role="WindowText">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>128</red>
      <green>128</green>
      <blue>128</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Button">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>32</red>
      <green>64</green>
      <blue>96</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Light">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>24</red>
      <green>48</green>
      <blue>44</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Text">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>128</red>
      <green>128</green>
      <blue>128</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="BrightText">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>24</red>
      <green>48</green>
      <blue>64</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="ButtonText">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>128</red>
      <green>128</green>
      <blue>128</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Base">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>12</red>
      <green>24</green>
      <blue>32</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Window">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>12</red>
      <green>24</green>
      <blue>32</blue>
     </color>
    </brush>
   </colorrole>

   <colorrole role="Shadow">
    <brush brushstyle="SolidPattern">
     <color alpha="255">
      <red>65</red>
      <green>113</green>
      <blue>145</blue>
     </color>
    </brush>
   </colorrole>

  </disabled>
 </palette>
</property>
#endif
//--------------------------------------------------------
// Задание начального набора значений
double **MainBox::getData(int n)
{
    double **f;
    f = new double*[2];
    f[0] = new double[n];
    f[1] = new double[n];
    for (int i = 0; i<n; i++)
    {
        f[0][i] = (double)i;
        f[1][i] = 8 * (double)i - 3;
        // Добавление случайной составляющей
        f[1][i] = 8*(double)i - 3 + ((rand()%100)-50)*0.05;
    }
    return f;
}
//--------------------------------------------------------
// Вычисление коэффициентов аппроксимирующей прямой
void MainBox::getApprox(double **x, double *a, double *b, int n)
{
    double sumx = 0;
    double sumy = 0;
    double sumx2 = 0;
    double sumxy = 0;
    for (int i = 0; i<n; i++)
    {
        sumx += x[0][i];
        sumy += x[1][i];
        sumx2 += x[0][i] * x[0][i];
        sumxy += x[0][i] * x[1][i];
    }
    *a = (n*sumxy - (sumx*sumy)) / (n*sumx2 - sumx*sumx);
    *b = (sumy - *a*sumx) / n;
    return;
}
//--------------------------------------------------------
QString title = "Заголовок";
QString text = "Текст";

QMessageBox msgBox;
msgBox.setIcon(QMessageBox::Information);
msgBox.setWindowTitle(title);
msgBox.setText(text);
msgBox.setStandardButtons(QMessageBox::Ok);

msgBox.setCheckBox(new QCheckBox("что-то написано"));

int btn = msgBox.exec();
if(btn == QMessageBox::Ok)
{
    QCheckBox *cb = msgBox.checkBox();
    if(cb)
    {
        emit info(QString("%1").arg(cb->isChecked() ? "true" : "false"));
    }
}
//--------------------------------------------------------
#include <QTreeView>
#include "test_model/test_model.hpp"
// http://webhamster.ru/mytetrashare/index/mtb0/1438881056ul2fzqj0ny
Test_model *model = 0;

model = new Test_model();

QTreeView *w = new QTreeView();
w->setModel(model);
w->setMinimumSize(640, 480);
w->show();

if(model)
{
    QVariant value;
    bool ok = model->get(0,0,&value);
    if(ok)
    {
        int x = value.toInt() + 1;
        model->set(0, 0, x);
    }
}
//--------------------------------------------------------
QPalette Pal(palette());
Pal.setColor(QPalette::Background, Qt::red);

QWidget *w = new QWidget;
w->setFixedSize(300, 300);
w->setPalette(Pal);
w->show();
//--------------------------------------------------------
QString title = "Заголовок";
QString text = "Текст";

QMessageBox msgBox;
msgBox.setIcon(QMessageBox::Information);
msgBox.setWindowTitle(title);
msgBox.setText(text);
msgBox.setStandardButtons(QMessageBox::Ok);

msgBox.setCheckBox(new QCheckBox("что-то написано"));

int btn = msgBox.exec();
if(btn == QMessageBox::Ok)
{
    QCheckBox *cb = msgBox.checkBox();
    if(cb)
    {
        emit info(QString("%1").arg(cb->isChecked() ? "true" : "false"));
    }
}
//--------------------------------------------------------
#if 0
    QStandardItemModel *model = new QStandardItemModel(5, 5);
    for (int row = 0; row < model->rowCount(); ++row)
    {
        for (int column = 0; column < model->columnCount(); ++column)
        {
            QStandardItem *item = new QStandardItem(QString("row %0, column %1").arg(row).arg(column));
            model->setItem(row, column, item);
        }
    }
#else
    QList<QStandardItem *> sl;
    for(int n=0; n<5; n++)
    {
        sl.append(new QStandardItem(QString("item %1").arg(n)));
    }

    QStandardItem *item = new QStandardItem;
    item->appendColumn(sl);

    QStandardItemModel *model = new QStandardItemModel();
    //model->setHorizontalHeaderLabels(QStringList() << "x1" << "x2"<< "x3" << "x4" << "x5" << "x6");
    model->appendRow(item);
#endif
    QTreeView *tv = new QTreeView;
    tv->setModel(model);
    //tv->setC
    tv->show();
//--------------------------------------------------------
emit info(QDir::homePath());
//--------------------------------------------------------
ui->comboBox->addItem("0");
ui->comboBox->addItem("1");
ui->comboBox->addItem("2");
ui->comboBox->addItem("3");

ui->comboBox->setCurrentIndex(-1);
//--------------------------------------------------------
#if 0
    QStringList sl;
    sl << "тест";

    bool ok = create_pixmap((QWidget *)&sl, this);
    if(ok == false)
    {
        emit error("FAIL");
        return false;
    }
    emit info("OK");
#endif
//--------------------------------------------------------
#if 0
    QString str = "1|12|123|1234|12345";
    QStringList sl = str.split('|');
    foreach (QString text, sl)
    {
        emit info(text);
    }
#endif
//--------------------------------------------------------
#if 0
    QDateTime dt = QDateTime::currentDateTime();
    QString str = dt.toString("XXX dd.MM.yy hh:mm:ss");
    emit info(QString("[%1]").arg(str));
#endif
//--------------------------------------------------------
#include <QNetworkInterface>
#if 0
    //---
    QList<QNetworkInterface> myInterfaces = QNetworkInterface::allInterfaces();
    foreach (QNetworkInterface iface, myInterfaces)
    {
        if(!iface.name().contains("lo"))
        {
            emit info("---");
            emit info(QString("name %1").arg(iface.name()));
            emit info(QString("humanReadableName %1").arg(iface.humanReadableName()));
            emit info(QString("hardwareAddress %1").arg(iface.hardwareAddress()));

            QList<QNetworkAddressEntry> entry_list = iface.addressEntries();
            foreach (QNetworkAddressEntry entry, entry_list)
            {
                QAbstractSocket::NetworkLayerProtocol proto = QHostAddress(entry.ip()).protocol();
                if(proto == QAbstractSocket::IPv4Protocol)
                {
                    emit info(QString("IPV4 %1").arg(entry.ip().toString()));
                }
            }
        }
    }
#endif
//--------------------------------------------------------
#if 1
double k = 0.5;
QRadialGradient *gradient = new QRadialGradient(10,10,10,10,10);
gradient->setColorAt(0.0,     QColor(0,   0,   0));
gradient->setColorAt(0.2 * k, QColor(85,  0,   170));
gradient->setColorAt(0.4 * k, QColor(170, 0,   170));
gradient->setColorAt(0.6 * k, QColor(255, 85,  0));
gradient->setColorAt(0.8 * k, QColor(255, 170, 0));
gradient->setColorAt(1.0,     QColor(255, 255, 255));

gradient->setColorAt(0, QColor::fromRgbF(0, 1, 0, 1));
gradient->setColorAt(1, QColor::fromRgbF(0, 0, 0, 0));

QBrush *brush = new QBrush(*gradient);
#else
QBrush brush(Qt::green);
#endif

p.setBrush(*brush);
//--------------------------------------------------------
void Load()
{
    int num_verts;
    char tmp;          //this is to skip ';' and ',' syntax in the file
    int num_faces;
    int num_texs;
    float data;

    //open up the file and print how many vertices to load
    ifstream file;
    file.open("balls.txt");

    file >> num_verts;
    file >> tmp;

    //Load Vertex Data
    for(int i = 0; i < num_verts; i++)
    {
        for(int j = 0; j < 3; j++)
        {
            file >> data;
            //makeup for the y,z axis conversion
            if(j==0)
            {
                ball_vertices[i][0] = data;
            }

            if(j == 1)
            {
                ball_vertices[i][2] = data;
            }
            if(j==2)
            {
                ball_vertices[i][1] = data*-1;
            }
            file >> tmp;
        }
        file >> tmp;
    }

    file >> num_faces;
    file >> tmp;

    //Load Face Data

    for(int i = 0; i < num_faces; i++)
    {
        file >> num_verts;
        ball_faces[i] = num_verts;
        file >> tmp;
        //Dont do anything with the data afterwards
        for(int j = 1; j < num_verts+1; j++)
        {
            file >> data;
            file >> tmp;
        }
        file >> tmp;
    }

    file >> num_texs;
    file >> tmp;
    //Load Texture Data
    for(int i = 0; i < num_texs; i++)
    {
        for(int j = 0; j < 2; j++)
        {
            file >> data;
            ball_texs[i][j] = data;
            file >> tmp;
        }
        file >> tmp;
    }

    file.close();
}
//--------------------------------------------------------
#include <QFormBuilder>
#include <QGridLayout>


QFormBuilder fb;
QFile fileOut("xxx.ui");

bool ok = fileOut.open(QIODevice::ReadWrite);
emit info(QString("ok is %1").arg(ok ? "true" : "false"));

QPushButton *x0 = new QPushButton();
QPushButton *x1 = new QPushButton();
QPushButton *x2 = new QPushButton();

x0->setText("x0");
x1->setText("x1");
x2->setText("x2");

x0->setObjectName("x0");
x1->setObjectName("x1");
x2->setObjectName("x2");

QGridLayout *grid = new QGridLayout();
grid->addWidget(x0, 0, 0);
grid->addWidget(x1, 1, 0);
grid->addWidget(x2, 2, 0);

QWidget *w = new QWidget();
w->setLayout(grid);
w->show();

fb.save(&fileOut, w);
//--------------------------------------------------------
void MainBox::paintEvent(QPaintEvent *)
{
    QPainter p(this);
    p.setPen(QPen(Qt::red, 1, Qt::SolidLine));
    p.drawLine(0, 0, width(), height());
    p.drawLine(0, height(), width(), 0);
}
//--------------------------------------------------------
Param<int> temp;
temp.set(6);
emit info(QString("%1").arg(temp.get()));

Param<float> temp2;
temp2.set(6.5);
emit info(QString("%1").arg(temp2.get()));

Param<QString> temp3;
temp3.set("проба");
emit info(QString("%1").arg(temp3.get()));

Param<QByteArray> temp4;
temp4.set("11111");
emit info(QString("%1").arg(temp4.get().toHex().data()));
//--------------------------------------------------------
#include <QDateTime>

QString s0 = "";
QString s1 = "";
QString s2 = "";

QStringList sl;

sl << "LOG_EMERG  "
   << "LOG_ALERT  "
   << "LOG_CRIT   "
   << "LOG_ERR    "
   << "LOG_WARNING"
   << "LOG_NOTICE "
   << "LOG_INFO   "
   << "LOG_DEBUG  ";

foreach (QString lvl, sl)
{
    QDateTime dtime = QDateTime::currentDateTime();

    s0 = dtime.toString("dd-MM-yy hh:mm:ss");
    s1 = lvl;
    s2 = "message";
    emit info(QString("%1\t%2\t%3").arg(s0).arg(s1).arg(s2));
}
//--------------------------------------------------------
#ifdef Q_OS_LINUX
    #include <syslog.h>
#endif
#include <QProgressDialog>
#include <QProgressBar>
#include "sleeper.h"

#if 1
    QProgressBar *p_bar = new QProgressBar();
    p_bar->setMinimum(0);
    p_bar->setMaximum(0);

    QStyle *style = QStyleFactory::create("Fusion");
    if(style)
    {
        p_bar->setStyle(style);
    }
    else
    {
        emit error("Style is FAIL");
    }

    QProgressDialog progress("Пожалуйста, ждите!", 0, 0, 0, this);
    progress.setWindowFlags(Qt::SplashScreen);
    //progress.setWindowFlags(Qt::Dialog | Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowContextHelpButtonHint);
    //progress.setWindowModality(Qt::WindowModal);
    progress.setFixedWidth(320);
    progress.setBar(p_bar);
    progress.show();

    for(int n=0; n<1000; n++)
    {
        qApp->processEvents();
        Sleeper::msleep(10);
    }

    progress.close();
#endif

#ifdef Q_OS_LINUX
    syslog(LOG_EMERG,   "LOG_EMERG");
    syslog(LOG_ALERT,   "LOG_ALERT");
    syslog(LOG_CRIT,    "LOG_CRIT");
    syslog(LOG_ERR,     "LOG_ERR");
    syslog(LOG_WARNING, "LOG_WARNING");
    syslog(LOG_NOTICE,  "LOG_NOTICE");
    syslog(LOG_INFO,    "LOG_INFO");
    syslog(LOG_DEBUG,   "LOG_DEBUG");
#endif
//--------------------------------------------------------
#include <windows.h>

#define VER_FILEVERSION             1,0,0,0
#define VER_FILEVERSION_STR         "1.0.0.0\0"
#define VER_PRODUCTVERSION          1,0,0
#define VER_PRODUCTVERSION_STR      "1.0.0\0"
#define VER_FILEDESCRIPTION_STR     "HelloWorld"
#define VER_INTERNALNAME_STR        "Sensor"
#define VER_LEGALCOPYRIGHT_STR      "Copyright (C) 2015, MyCompany"
#define VER_ORIGINALFILENAME_STR    "HelloWorld.exe"
#define VER_PRODUCTNAME_STR         "Hello World"

VS_VERSION_INFO VERSIONINFO
FILEVERSION     VER_FILEVERSION
PRODUCTVERSION  VER_PRODUCTVERSION
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904E4"
        BEGIN
            VALUE "FileDescription",    VER_FILEDESCRIPTION_STR
            VALUE "FileVersion",        VER_FILEVERSION_STR
            VALUE "InternalName",       VER_INTERNALNAME_STR
            VALUE "LegalCopyright",     VER_LEGALCOPYRIGHT_STR
            VALUE "OriginalFilename",   VER_ORIGINALFILENAME_STR
            VALUE "ProductName",        VER_PRODUCTNAME_STR
            VALUE "ProductVersion",     VER_PRODUCTVERSION_STR
        END
    END

    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END
